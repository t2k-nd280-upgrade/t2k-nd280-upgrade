#include "ExN02TrackerHit.hh"

#include "G4UnitsTable.hh"
#include "G4VVisManager.hh"
#include "G4Circle.hh"
#include "G4Colour.hh"
#include "G4VisAttributes.hh"
#include <fstream>

#include "Const.hh"

#define SideView 0 // resolution of vertical-direction

// allocator
G4Allocator<ExN02TrackerHit> ExN02TrackerHitAllocator;

//ExN02TrackerHit::ExN02TrackerHit(G4int dID0, G4int P0, G4int trkid, G4double e, G4double e_q, const G4ThreeVector& pos, G4double t) 
ExN02TrackerHit::ExN02TrackerHit(G4int dID0, G4int P0, G4int trkid, G4double e, G4double eq, G4ThreeVector pos, G4double t) 
{
  detID = dID0;
  trackID = trkid;
  edep = e;
  edep_q = eq;
  Particle = P0;
  //for(int i=0;i<3;i++) position[i] = pos[i];
  position = pos;
  time = t;

    mod = dID0/264;              // 264 scnti-bar / module
    pln = (dID0-mod*264)/24;     // 24 channel / plane
    ch = dID0-mod*264-pln*24;    //24 ch /plane  


    view = SideView;

    //loli Module added by koga
    if(mod>=20){
      mod=15;
      pln = (dID0-20*264)/CHMAX;
      ch = dID0-20*264-pln*CHMAX;
    }
   


    //Proton Module added by kikawa
    else if(mod>=16){
      mod=16;
      pln = (dID0-mod*264+8)/32;


      if(pln==0){
	pln=0;
	ch=dID0-mod*264;
      }
      else ch = dID0-mod*264+8-pln*32;
    }



    //if(ch>31||ch<0)cout<<"error ch"<<ch<<endl;
    //if(pln>17||pln<0)cout<<"error pln"<<pln<<endl;


    //B. Quilain, to update
    /*
    if( mod<=6 ) {
      posinmod[0] = pos[0] + (150*cm)*(3-mod);
        posinmod[1] = pos[1];
        posinmod[2] = pos[2];
    }

    else if( mod>=7 && mod<=14 ) {
        posinmod[0] = pos[0];
        posinmod[1] = pos[1] + (150*cm)*(10-mod);
        posinmod[2] = pos[2] + 400*cm;
    }

    //Proton Module added by kikawa
    else if(mod==16){
      posinmod[0] = pos[0];
      posinmod[1] = pos[1];
      posinmod[2] = pos[2] + (120*cm);
    }
 
    //Prototype of WAGASCI added by koga
    else if(mod==15){
      posinmod[0] = pos[0];
      posinmod[1] = pos[1];
      posinmod[2] = pos[2] + (120*cm);
    }   
    */
    
    //aded by koga for crosstalk study 2016/1/13 
    gridcell_id_x1=-1;
    gridcell_id_x2=-1;
    gridcell_id_y1=-1;
    gridcell_id_y2=-1;

    if(mod==15){
      //INGRID_Dimension *fdim = new INGRID_Dimension();
      //fdim->get_loli_gridcell_id(mod,view,pln,ch,posinmod[0]/cm,posinmod[1]/cm,posinmod[2]/cm,&gridcell_id_x1,&gridcell_id_x2,&gridcell_id_y1,&gridcell_id_y2);
    }   


    //
	/*
    INGRID_Dimension *fdim = new INGRID_Dimension();
    double posxy, posz;
    fdim->get_posXY(mod,view,pln,ch,&posxy,&posz);

    //
    inghit.Clear("C");
    inghit.mod = mod;
    inghit.view = view;
    inghit.pln = pln;
    inghit.ch = ch;
    inghit.xy = posxy;
    inghit.z = posz;
    inghit.time = t;

    //
    ingsimhit.Clear("C");
    ingsimhit.edeposit = edep;
    ingsimhit.trackid = trkid;
    ingsimhit.pdg = P0;
	*/

    //inghit.AddIngridSimHit(&ingsimhit);

//	if(fdim) delete fdim;
}

ExN02TrackerHit::ExN02TrackerHit(G4int dID0, G4double e,G4int P0) 
{
  detID = dID0;
  edep = e;
  Particle = P0;

}

ExN02TrackerHit::ExN02TrackerHit(G4int dID0, G4double e) 
{
  detID = dID0;
  edep = e;

}


ExN02TrackerHit::~ExN02TrackerHit() 
{
}

ExN02TrackerHit::ExN02TrackerHit(const ExN02TrackerHit &right)
  : G4VHit()
{
  detID = right.detID;
  edep       = right.edep;
  Particle = right.Particle;

  for(int i=0;i<3;i++) position[i] = right.position[i];
  eventID = right.eventID;

}

const ExN02TrackerHit& ExN02TrackerHit::operator=(const ExN02TrackerHit &right)
{
  detID = right.detID;
  edep       = right.edep;
  Particle = right.Particle; 
  
  for(int i=0;i<3;i++) position[i] = right.position[i];
  eventID = right.eventID;


  return *this;
}

G4int ExN02TrackerHit::operator==(const ExN02TrackerHit &right) const
{
  return (this==&right) ? 1 : 0;
}  

G4int ExN02TrackerHit::CompareID(const ExN02TrackerHit right) 
{
  return (detID==right.detID) ? 1 : 0;
}


G4int ExN02TrackerHit::CompareP(const ExN02TrackerHit right) 
{
  return (Particle==right.Particle) ? 1 : 0;
}

G4int ExN02TrackerHit::isFaster(const ExN02TrackerHit right)
{
  return (time>right.time) ? 1 : 0;
}
G4int ExN02TrackerHit::LargerEdep(const ExN02TrackerHit right)
{
  //return (Particle==11||right.Particle!=11) ? 1 : 0;
  if(Particle==11) return 1;
  else if(right.Particle==11) return 0;
  else return (edep<right.edep) ? 1 : 0;
}

void ExN02TrackerHit::Draw()
{
    double size = edep + 7.;
    if( edep>9 ) size = 16.;
  #if 1
  G4VVisManager* pVVisManager = G4VVisManager::GetConcreteInstance();
  if(pVVisManager)
    {
      G4ThreeVector pos; 
      for(int i=0;i<3;i++) pos[i] = position[i]*mm;
      G4Circle circle(pos);
      circle.SetScreenSize(size); 
      circle.SetFillStyle(G4Circle::filled);
      G4Colour colour(0.,1.,1.3); //cyan
      G4VisAttributes attribs(colour);
      circle.SetVisAttributes(attribs);
      pVVisManager->Draw(circle);
    }
  #endif
}

void ExN02TrackerHit::Print()
{
  G4cout.precision(4);
  
  G4cout << " Mod:" << mod 
		 //<< " detID:" << detID
         << " Pln:" << pln 
		 << " Ch:" << ch 
		 << " Time:" << time
	//<< "  Edep:" << G4BestUnit(edep,"Energy")
		 << " Edep:" << edep
		 << " p.e.:" << pe
         << " PID:" << Particle
//		 << G4endl;
		 << " Trk:" << trackID
         << " pos:{" << position[0]/*/cm*/ << ", "
         << position[1]/*/cm*/ << ", " << position[2]/*/cm*/
         << "}" << G4endl;

}


void ExN02TrackerHit::Print_Hit()
{

  std::ofstream yokoHit_ofs;
  yokoHit_ofs.open("yokoHit", std::ofstream::app);
  if (yokoHit_ofs.good()){
    yokoHit_ofs  << eventID << "   " << detID << "   " << Particle << "   " << edep << "   ";
  }
  
  yokoHit_ofs.close();
  
}


